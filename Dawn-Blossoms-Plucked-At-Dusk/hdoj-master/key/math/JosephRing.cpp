/**
 * 约瑟夫环问题
 * 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。
 * 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
 * */
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include <queue>

using namespace std;

int main() {
    int n, m;
    while (cin >> n >> m) {
        int res = 0;
        for (int i = 2; i <= n; ++i) {
            res = (res + m) % i;
        }

        cout << res << endl;
    }
    return 0;
}
/**
 * 约瑟夫环其实可以模拟这个过程，但数据量一大就容易gg
 * 其实可以数学推导，过程如下
 * 可以这么理解，不被删除的数就是不被选中的数，不被选中的数在每次删除操作中都不会删除
 * 比如有n个数，删完还剩n-1个数
 * 如果我已经知道在n-1个数中，最终答案的索引是多少(位于第几个)，我完全可以逆推出没删之前最终答案的索引(就是最初排列排第几个)
 * 例如在n-1个情况下，最终答案的索引为x 则在n个的情况下，最终答案的索引为（x + m）% n（模拟一下删除过程，就知道这个公式的含义）,
 * 如何知道n-1个情况下的答案索引位置，看n-2，知道还剩一个数的时候，那就别算了，正好是0，这时一波反推，反推出n个情况下最终答案的
 * 索引位置，因本题索引位置与答案一致，直接输出索引值即答案值即可
 * */