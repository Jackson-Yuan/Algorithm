#include<stdio.h>

int dp[101][101];

int main() {
    int k, l;
    scanf("%d%d", &k, &l);
    for (int i = 0; i < k; i++) {
        dp[1][i] = 1;
    }

    for (int i = 2; i <= l; i++) {
        for (int j = 0; j < k; j++) {
            for (int x = 0; x < k; x++) {
                if (x != j - 1 && x != j + 1) {
                    dp[i][j] += dp[i - 1][x];
                    dp[i][j] %= 1000000007;
                }
            }
        }
    }
    int sum = 0;
    for (int i = 1; i < k; i++) {
        sum += dp[l][i];
        sum %= 1000000007;
    }
    printf("%d\n", sum);
}
/*
此题大衣是 给你L为k进制数 这个数相邻两位不能是相邻的数 但根据题目中的样例 发现 首位为0的时候 组成的数是不算的
动态规划 原理很简单 先撇开那个bitch的条件 dp[i][j]代表i为数中最后一位为j的情况下为多少种 那么dp[i][j]的值肯定等于他他前面一位且与他不相邻的数(即j) 的所有和
但由于那个bitch的条件 我们不妨倒过来看 如 样例中的4 2 答案有11 13 20 22 30 31 33 因为首位不为0 我们可以到看 如 11 31 02 22 03 13 33 这样的话把末位看成首位
在求和的时候 踢掉j为0的情况就完事了

有时推导递推式时 主要还是明确dp数组的意义 这真的很重要 意义选的好 很容易推导 还是菜啊~~~~ 
*/
