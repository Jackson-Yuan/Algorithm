/**
出栈次序
X星球特别讲究秩序，所有道路都是单行线。一个甲壳虫车队，共16辆车，按照编号先后发车，夹在其它车流中，缓缓前行。
路边有个死胡同，只能容一辆车通过，是临时的检查站，如图【p1.png】所示。
X星球太死板，要求每辆路过的车必须进入检查站，也可能不检查就放行，也可能仔细检查。
如果车辆进入检查站和离开的次序可以任意交错。那么，该车队再次上路后，可能的次序有多少种？
为了方便起见，假设检查站可容纳任意数量的汽车。
显然，如果车队只有1辆车，可能次序1种；2辆车可能次序2种；3辆车可能次序5种。
现在足足有16辆车啊，亲！需要你计算出可能次序的数目。

题意：求n个元素的出栈情况有多少种。
*/
#include<stdio.h>

int f(int n) {
    if (n <= 2) return n;
    else {
        int sum = 0;
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                sum += 1 * f(n - 1 - i);
            } else if (i == n - 1) {
                sum += f(i) * 1;
            } else {
                sum += f(i) * f(n - 1 - i);
            }
        }
        return sum;
    }
}

int main() {
    printf("%d", f(16));
}
/**
此题思路 就是按照1号车最终出栈的位置来划分 在第一位 则后面n-1个为f(n - 1) 若为第二个 则前面一个 后面n-2个 以此类推可以利用乘法原理算出结果 
起初想法是按每辆车放第一位来划分 发现比较难求 
*/ 
