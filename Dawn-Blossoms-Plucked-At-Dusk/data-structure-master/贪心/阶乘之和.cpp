#include<stdio.h>

int f(int n) {
    if (n == 1) return 1;
    else return n * f(n - 1);
}

int main() {
    int a[10];
    for (int i = 0; i < 10; i++) {
        a[i] = f(i + 1);
    }
    int n;
    scanf("%d", &n);
    while (n--) {
        int m;
        scanf("%d", &m);
        for (int i = 9; i >= 0; i--) {
            if (m >= a[i]) m -= a[i];
        }
        if (m == 0) printf("Yes\n");
        else printf("No\n");
    }
}
/*
此题 乍一看有点搞不清头绪 各个数的阶乘之和为目标值  第一想法 根据目标数的范围 撑死到9
的阶乘  可以向将前9个数的阶乘打表 提高运行速度 然后直接无脑dfs随机选数 到目标值 或者比目标值大
就停止判断一波 但这样八成超时 其实真正的解法很简单 这个数由其他数加起来 肯定是比他小的数加起来
然后比如6  有 1 2 3 也有可能是5 1  我可能会想 万一像代码那样减早了咋办 
其实压根不需要担心 其实 抛开此题的条件 一个数分解成若干数之后 有很多种情况 且这些情况可以相互之间转化
比如1 2 3 可以转换成1 5 但这题特殊在 要被加的数 都是阶乘所得 目标数若能成功分解 必定是其中最小值的倍数关系
所以 比如 题目的阶乘 序列 1 2 6 24 120  如果目标数大于120 是不可能出现减早的情况 因为 120 之前的数全部加起来都没120大 
*/ 
