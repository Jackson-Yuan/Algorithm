#include<stdio.h>

int main() {
    long long n;
    scanf("%lld", &n);
    long long sum = 0;
    if (n % 2) {
        sum = n * (n - 1) * (n - 2);
    } else {
        if (n % 3) sum = n * (n - 1) * (n - 3);
        else sum = (n - 1) * (n - 2) * (n - 3);
    }

    printf("%lld\n", sum);
}
/*分析一波 找到从一到n找三个数 使得他们的最小公倍数为最大  这个没得谈 大致上肯定倒着找
但因为不要忘记 最小公倍数不仅仅是简单的相乘 而是相乘之后除去他们的最大公因数 所以需要分n为奇数偶数
因为大原则上我们想要n n-1 n-2 但n为偶数时 n 与 n-2 肯定有公因子2 所以公倍数会缩水 不如n-2 换成 n-3(尽可能大嘛 贪心) 但是 n 还有可能与n - 3有公因子3 那么就把n 换为n-2(尽可能大嘛 贪心) 
当n为奇数时 没得说 n n-1 n-2 不可能有公因子 完事儿 

至于这道题目为什么当时没搞出来 天真地直接n n-1 n-2乘
主要因为对数自身奇偶性质不熟悉 再之分析能力还不够 
分析能力不够的原因 主要是基础知识不够 无法做出有效的分析 
*/
